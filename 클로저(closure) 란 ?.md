# **클로저란?**

- 반환된 내부함수가 자신이 선언됬을때의 환경인 스코프를 기억하여 자신이 선언되었을때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수, 자신이 생성될때의 환경을 기억하는 함수

먼저 Closure라는 뜻을 사전에서 찾아보시면 **폐쇄**라는 뜻을 가지고 있다.

마찬가지로 자바스크립트(JS)의 클로저도 폐쇄와 유사한 의미를 가지고 있다. 폐쇄 즉, 갇히는 것이다.

한 마디로 클로저란, **함수가 선언될(생성될) 그 당시에 주변의 환경과 함께 갇히는 것**을 말한다.

또 다른 말로 설명하면, **함수가 속한 렉시컬 스코프(Lexical Environment)를 기억하여, 함수가 렉시컬 스코프 밖에서 실행될 때도 이 스코프에 접근할 수 있게 해주는 기능**이다.

여기서 렉시컬 스코프란 개념이 생소하실 수도 있을 것 같은데요. **렉시컬 스코프란 함수가 선언이 되는 위치에 따라서 상위 스코프가 결정되는 스코프**이다. 함수가 선언이 될 때, 스코프가 생성된다.

또 다른 클로저의 뜻으로는 **내부함수는 외부함수의 지역변수에 접근할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근할 수 있는 것**을 말한다.

예시)

```jsx
function sayHello () {
  const a = 'Hello';
  const b = 'World';

  function sumString () {
    console.log(a + ' ' + b);
  }

  return sumString;
}

const myFunc = sayHello();

myFunc();// 'Hello World'
```

예제를 살펴보면, myFunc라는 변수는 sayHello 함수를 호출하고 있다. 그래서 myFunc를 실행하게 되면 어떠한 문제 없이 Hello World가 잘 출력된다.

여기서 살펴볼 점은 myFunc의 부분은 변수 a와 b가 담겨 있는 sayHello 함수 스코프의 바깥에 있는데도 불구하고 a와 b를 합친 Hello World를 잘 출력한다는 것이다.

그 이유가 바로 클로저(Closure) 때문이다.

모든 자바스크립트 함수는 선언(생성)될 당시에 클로저가 형성되어 주변 환경, 즉 렉시컬 스코프를 기억할 수 있게 되는 것이다.
